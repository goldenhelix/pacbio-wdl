name: Sawfish
description: Discover and call structural variants with Sawfish.
auto_generate_session_for_account: "{workspaceBot}" 

agent_requirements:
  cpu_cores: 32
  memory_gb: 128

parameters: 
  - name: sample_id
    label: Sample ID
    type: string
    description: "Sample ID"
    
  - name: aligned_bam
    label: Aligned BAM
    type: file
    pattern_match:
      - "*.bam"
    description: "Aligned BAM file"
    
  - name: small_variant_vcf
    label: Small Variant VCF
    type: file
    pattern_match:
      - "*.vcf"
      - "*.vcf.gz"
    description: "Small variant VCF file generated by DeepVariant. If not provided, the VCF path will be inferred from the BAM. "
    optional: true

  - name: output_folder
    label: Output Folder
    type: directory
    supports_location_mode: 'no_append'
    
  - name: cache_udocker_images
    label: Cache Udocker Image
    type: boolean
    value: true

steps:
- name: sawfish
  type: cmd
  description: Run sawfish to discover and call structural variants
  args: 
    - |- # shell
      set -eu pipefail

      # Set up resource path
      PB_RESOURCES_DIR="${WORKSPACE_DIR}/${RESOURCES_PATH}/hifi-wdl-resources-v3.0.0"
      # TASK_NAME=$(basename "$(dirname "$(dirname "$(dirname "$(dirname "$PWD")")")")")
      
      # Ensure TASK_NAME is set for debug capture
      if [ -z "${TASK_NAME:-}" ]; then
        TASK_NAME="sawfish"
        echo "Warning: TASK_NAME not set, using default: $TASK_NAME"
      fi

      # Get sample sex from catalog
      echo "Looking up sample sex for: $sample_id"
      set +e
      sex=$(gautil client catalog-export SampleCatalog Sample:eq:"$sample_id" --fields="Sex" | tail -n 1 | tr -d '\r\n\t ')
      sex_lookup_exit_code=$?
      set -e
      
      if [ $sex_lookup_exit_code -ne 0 ] || [ -z "$sex" ] || [ "$sex" != "Male" ] && [ "$sex" != "Female" ]; then
        echo "Warning: Could not determine sex for sample $sample_id (exit code: $sex_lookup_exit_code, value: '$sex'), defaulting to Female"
        sex="Female"
      fi
      
      # Convert to uppercase for consistency with existing logic
      if [ "$sex" = "Male" ]; then
        sex="MALE"
      elif [ "$sex" = "Female" ]; then
        sex="FEMALE"
      fi

      # Function to handle miniwdl failure
      handle_miniwdl_failure() {
        local exit_code=$1
        echo "MiniWDL run failed with exit code $exit_code"
        echo "Capturing debug information..."
        bash "$TASK_DIR/miniwdl-debug-capture.sh" /scratch/_LAST "$output_folder" "$TASK_NAME"
        exit $exit_code
      }

      # Set environment variables for miniwdl
      export MINIWDL__SCHEDULER__CONTAINER_BACKEND=udocker
      export MINIWDL__FILE_IO__ALLOW_ANY_INPUT=true
      export MINIWDL__SCHEDULER__TASK_CONCURRENCY=8
      export UDOCKER_DIR=/scratch/.udocker
      
      # Set up reference files (hardcoded from ref_map)
      REF_FASTA="${PB_RESOURCES_DIR}/GRCh38/human_GRCh38_no_alt_analysis_set.fasta"
      REF_INDEX="${PB_RESOURCES_DIR}/GRCh38/human_GRCh38_no_alt_analysis_set.fasta.fai"
      EXCLUDE_BED="${PB_RESOURCES_DIR}/GRCh38/sawfish/annotation_and_common_cnv.hg38.bed.gz"
      EXCLUDE_BED_INDEX="${PB_RESOURCES_DIR}/GRCh38/sawfish/annotation_and_common_cnv.hg38.bed.gz.tbi"
      EXPECTED_MALE_BED="${PB_RESOURCES_DIR}/GRCh38/sawfish/expected_cn.hg38.XY.bed"
      EXPECTED_FEMALE_BED="${PB_RESOURCES_DIR}/GRCh38/sawfish/expected_cn.hg38.XX.bed"

      # Find index files
      aligned_bam_index="${aligned_bam}.bai"
      if [ -n "$small_variant_vcf" ]; then
        small_variant_vcf_index="${small_variant_vcf}.tbi"
      else
        small_variant_vcf=$(echo "${aligned_bam}" | cut -d '.' -f 1).small_variants.vcf.gz
        small_variant_vcf_index="${small_variant_vcf}.tbi"
      fi

      # Verify reference files exist
      if [ ! -f "$REF_FASTA" ]; then
        echo "Error: Reference FASTA file not found at $REF_FASTA"
        echo "Please ensure the PacBio WDL resources have been downloaded using the Download PacBio Reference Data Resources task"
        exit 1
      fi

      if [ ! -f "$REF_INDEX" ]; then
        echo "Error: Reference FASTA index file not found at $REF_INDEX"
        echo "Please ensure the PacBio WDL resources have been downloaded using the Download PacBio Reference Data Resources task"
        exit 1
      fi

      if [ ! -f "$EXCLUDE_BED" ]; then
        echo "Error: Exclude BED file not found at $EXCLUDE_BED"
        echo "Please ensure the PacBio WDL resources have been downloaded using the Download PacBio Reference Data Resources task"
        exit 1
      fi

      if [ ! -f "$EXCLUDE_BED_INDEX" ]; then
        echo "Error: Exclude BED index file not found at $EXCLUDE_BED_INDEX"
        echo "Please ensure the PacBio WDL resources have been downloaded using the Download PacBio Reference Data Resources task"
        exit 1
      fi

      if [ ! -f "$EXPECTED_MALE_BED" ]; then
        echo "Error: Expected male BED file not found at $EXPECTED_MALE_BED"
        echo "Please ensure the PacBio WDL resources have been downloaded using the Download PacBio Reference Data Resources task"
        exit 1
      fi

      if [ ! -f "$EXPECTED_FEMALE_BED" ]; then
        echo "Error: Expected female BED file not found at $EXPECTED_FEMALE_BED"
        echo "Please ensure the PacBio WDL resources have been downloaded using the Download PacBio Reference Data Resources task"
        exit 1
      fi
      
      # Pull udocker layers from cache if requested
      if [ -d "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}" ]; then
        echo "Pulling udocker image from cache..."
        mkdir -p /scratch/.udocker
        cp -R "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}"/* /scratch/.udocker/
      fi
      
      # Check for required input files
      if [ ! -f "$aligned_bam" ]; then
        echo "Error: Aligned BAM file not found at $aligned_bam"
        exit 1
      fi
      
      if [ ! -f "$aligned_bam_index" ]; then
        echo "Error: BAM index file not found at $aligned_bam_index"
        exit 1
      fi
      
      if [ ! -f "$small_variant_vcf" ]; then
        echo "Error: Small variant VCF file not found at $small_variant_vcf"
        exit 1
      fi
      
      if [ ! -f "$small_variant_vcf_index" ]; then
        echo "Error: Small variant VCF index file not found at $small_variant_vcf_index"
        exit 1
      fi

      # Copy input files to /scratch
      echo "Copying input files to /scratch..."
      cp "${aligned_bam}" /scratch/
      cp "$aligned_bam_index" /scratch/
      cp "$small_variant_vcf" /scratch/
      cp "$small_variant_vcf_index" /scratch/
      
      # Copy reference files to /scratch
      echo "Copying reference files to /scratch..."
      cp "$REF_FASTA" /scratch/
      cp "$REF_INDEX" /scratch/
      cp "$EXCLUDE_BED" /scratch/
      cp "$EXCLUDE_BED_INDEX" /scratch/
      cp "$EXPECTED_MALE_BED" /scratch/
      cp "$EXPECTED_FEMALE_BED" /scratch/
      
      # Set local file paths
      LOCAL_BAM="/scratch/$(basename "${aligned_bam}")"
      LOCAL_BAM_INDEX="/scratch/$(basename "${aligned_bam_index}")"
      LOCAL_REF_FASTA="/scratch/$(basename "$REF_FASTA")"
      LOCAL_REF_INDEX="/scratch/$(basename "$REF_INDEX")"
      LOCAL_EXCLUDE_BED="/scratch/$(basename "$EXCLUDE_BED")"
      LOCAL_EXCLUDE_BED_INDEX="/scratch/$(basename "$EXCLUDE_BED_INDEX")"
      LOCAL_EXPECTED_MALE_BED="/scratch/$(basename "$EXPECTED_MALE_BED")"
      LOCAL_EXPECTED_FEMALE_BED="/scratch/$(basename "$EXPECTED_FEMALE_BED")"
      LOCAL_SMALL_VARIANT_VCF="/scratch/$(basename "${small_variant_vcf}")"
      LOCAL_SMALL_VARIANT_VCF_INDEX="/scratch/$(basename "${small_variant_vcf_index}")"

      # Create JSON structure for sawfish_discover inputs
      cat > /scratch/sawfish_discover_inputs.json << EOF
      {
        "sawfish_discover.sample_id": "$sample_id",
        "sawfish_discover.sex": "$sex",
        "sawfish_discover.aligned_bam": "$LOCAL_BAM",
        "sawfish_discover.aligned_bam_index": "$LOCAL_BAM_INDEX",
        "sawfish_discover.ref_fasta": "$LOCAL_REF_FASTA",
        "sawfish_discover.ref_index": "$LOCAL_REF_INDEX",
        "sawfish_discover.exclude_bed": "$LOCAL_EXCLUDE_BED",
        "sawfish_discover.exclude_bed_index": "$LOCAL_EXCLUDE_BED_INDEX",
        "sawfish_discover.expected_male_bed": "$LOCAL_EXPECTED_MALE_BED",
        "sawfish_discover.expected_female_bed": "$LOCAL_EXPECTED_FEMALE_BED",
        "sawfish_discover.small_variant_vcf": "$LOCAL_SMALL_VARIANT_VCF",
        "sawfish_discover.small_variant_vcf_index": "$LOCAL_SMALL_VARIANT_VCF_INDEX",
        "sawfish_discover.out_prefix": "${sample_id}",
        "sawfish_discover.runtime_attributes": {
          "backend": "HPC",
          "preemptible_tries": 0,
          "max_retries": 1,
          "zones": "",
          "cpuPlatform": "",
          "gpuType": "",
          "container_registry": "quay.io/pacbio"
        }
      }
      EOF
      cat /scratch/sawfish_discover_inputs.json

      # Run sawfish_discover with miniwdl
      echo "Running sawfish_discover..."
      set +e
      miniwdl run \
        --task sawfish_discover \
        "${TASK_DIR}/wdl/wdl-common/wdl/tasks/sawfish.wdl" \
        --dir /scratch \
        --runtime-cpu-max=$AGENT_CPU_CORES \
        --runtime-memory-max=${AGENT_MEMORY_GB}G \
        -i /scratch/sawfish_discover_inputs.json
      SAWFISH_DISCOVER_EXIT_CODE=$?
      set -e

      if [ $SAWFISH_DISCOVER_EXIT_CODE -ne 0 ]; then
        echo "sawfish_discover failed with exit code $SAWFISH_DISCOVER_EXIT_CODE"
        handle_miniwdl_failure $SAWFISH_DISCOVER_EXIT_CODE
      fi

      echo "sawfish_discover completed successfully"

      # tree /scratch/

      # We don't need to process the outputs here, we are only using this as inputs to the next step
      # bash "$TASK_DIR/process-outputs.sh" "$output_folder" "${sample_id}" 
      
      # Get the discover_tar output from sawfish_discover using outputs.json
      # First try to get it from the _LAST symlink (primary approach)
      DISCOVER_TAR=""
      if [ -f "/scratch/_LAST/outputs.json" ]; then
        DISCOVER_TAR=$(jq -r '.["sawfish_discover.discover_tar"]' /scratch/_LAST/outputs.json)
        echo "discover_tar from _LAST/outputs.json: $DISCOVER_TAR"
      fi
      
      # If primary approach failed, try alternative approach by finding the most recent sawfish_discover directory
      if [ -z "$DISCOVER_TAR" ] || [ "$DISCOVER_TAR" = "null" ]; then
        echo "Primary approach failed, trying alternative approach..."
        
        # Find the most recent sawfish_discover output directory
        SAWFISH_DISCOVER_DIR=$(find /scratch -maxdepth 1 -name "*_sawfish_discover" -type d | sort | tail -n 1)
        
        if [ -n "$SAWFISH_DISCOVER_DIR" ] && [ -f "$SAWFISH_DISCOVER_DIR/outputs.json" ]; then
          DISCOVER_TAR=$(jq -r '.["sawfish_discover.discover_tar"]' "$SAWFISH_DISCOVER_DIR/outputs.json")
          echo "discover_tar from $SAWFISH_DISCOVER_DIR/outputs.json: $DISCOVER_TAR"
        fi
      fi
      
      # Final validation
      if [ -z "$DISCOVER_TAR" ] || [ "$DISCOVER_TAR" = "null" ]; then
        echo "Error: Could not find discover_tar output from sawfish_discover using both approaches"
        echo "Attempted to read from:"
        echo "  - /scratch/_LAST/outputs.json"
        echo "  - Most recent sawfish_discover directory"
        exit 1
      fi
      
      echo "Found discover_tar: $DISCOVER_TAR"

      # Create JSON structure for sawfish_call inputs
      cat > /scratch/sawfish_call_inputs.json << EOF
      {
        "sawfish_call.sample_ids": ["$sample_id"],
        "sawfish_call.discover_tars": ["$DISCOVER_TAR"],
        "sawfish_call.aligned_bams": ["$LOCAL_BAM"],
        "sawfish_call.aligned_bam_indices": ["$LOCAL_BAM_INDEX"],
        "sawfish_call.ref_fasta": "$LOCAL_REF_FASTA",
        "sawfish_call.ref_index": "$LOCAL_REF_INDEX",
        "sawfish_call.out_prefix": "${sample_id}.structural_variants",
        "sawfish_call.runtime_attributes": {
          "backend": "HPC",
          "preemptible_tries": 0,
          "max_retries": 3,
          "zones": "",
          "cpuPlatform": "",
          "gpuType": "",
          "container_registry": "quay.io/pacbio"
        }
      }
      EOF
      cat /scratch/sawfish_call_inputs.json

      # Run sawfish_call with miniwdl
      echo "Running sawfish_call..."
      set +e
      miniwdl run \
        --task sawfish_call \
        "${TASK_DIR}/wdl/wdl-common/wdl/tasks/sawfish.wdl" \
        --dir /scratch \
        --runtime-cpu-max=$AGENT_CPU_CORES \
        --runtime-memory-max=${AGENT_MEMORY_GB}G \
        -i /scratch/sawfish_call_inputs.json
      SAWFISH_CALL_EXIT_CODE=$?
      set -e

      if [ $SAWFISH_CALL_EXIT_CODE -ne 0 ]; then
        echo "sawfish_call failed with exit code $SAWFISH_CALL_EXIT_CODE"
        handle_miniwdl_failure $SAWFISH_CALL_EXIT_CODE
      fi

      echo "sawfish_call completed successfully"
      bash "$TASK_DIR/process-outputs.sh" "$output_folder" "${sample_id}"

      # Check if the double-named file exists and rename it to canonical name
      DOUBLE_NAMED_VCF="${output_folder}/${sample_id}.structural_variants.structural_variants.vcf.gz"
      CANONICAL_VCF="${output_folder}/${sample_id}.structural_variants.vcf.gz"
      DOUBLE_NAMED_TBI="${output_folder}/${sample_id}.structural_variants.structural_variants.vcf.gz.tbi"
      CANONICAL_TBI="${output_folder}/${sample_id}.structural_variants.vcf.gz.tbi"
      
      if [ -f "$DOUBLE_NAMED_VCF" ]; then
        echo "Renaming double name structural_variants.vcf.gz to structural_variants.vcf.gz..."
        cp "$DOUBLE_NAMED_VCF" "$CANONICAL_VCF"
        rm "$DOUBLE_NAMED_VCF"
        echo "Copied and removed $DOUBLE_NAMED_VCF to $CANONICAL_VCF"
        
        if [ -f "$DOUBLE_NAMED_TBI" ]; then
          cp "$DOUBLE_NAMED_TBI" "$CANONICAL_TBI"
          rm "$DOUBLE_NAMED_TBI"
          echo "Copied and removed $DOUBLE_NAMED_TBI to $CANONICAL_TBI"
        fi
      fi
      
      # Copy udocker cache to output folder
      if [ "$cache_udocker_images" = true ] && [ ! -d "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}" ]; then
        echo "Copying udocker cache to resources folder..."
        mkdir -p "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}"
        cp -r /scratch/.udocker/layers /scratch/.udocker/repos "${WORKSPACE_DIR}/${RESOURCES_PATH}/udocker_cache/${TASK_NAME}" 2>/dev/null || true
      fi

      echo "Sawfish structural variant discovery and calling completed successfully"
      echo "Output files copied to: $output_folder"